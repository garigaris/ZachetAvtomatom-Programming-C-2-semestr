# Задачи для сдачи автоматом

## ЗАДАЧА №1: Проверка сбалансированности скобок с помощью стека

### Цель: Написать программу для проверки корректности расстановки круглых, фигурных и квадратных скобок в заданной строке.

Список идентификаторов

| Название       | Тип               | Смысл переменной                                                                |
|----------------|------------------|----------------------------------------------------------------------------------|
| `N`            | `#define`        | Максимальная длина вводимой строки                                               |
| `Stack`        | `struct`         | Структура для хранения данных стека                                              |
| `top`          | `int`            | Индекс последнего добавленного элемента в стеке                                  |
| `data`         | `char *`         | Указатель на массив символов — данные стека                                      |
| `size`         | `int`            | Максимальный размер стека                                                        |
| `init`         | `function`       | Инициализирует стек, выделяет память                                             |
| `push`         | `function`       | Добавляет символ в стек                                                          |
| `pop`          | `function`       | Извлекает символ из стека                                                        |
| `isMatch`      | `function`       | Проверяет, являются ли открывающая и закрывающая скобки парой                    |
| `isEmpty`      | `function`       | Проверяет, пуст ли стек                                                          |
| `isBalanced`   | `function`       | Проверяет строку на сбалансированность скобок                                    |
| `s`            | `char[]`         | Входная строка, вводимая пользователем                                           |
| `len`          | `size_t`         | Длина строки (для удаления символа новой строки `\n`)                            |
| `ok`           | `int`            | Флаг, равен 1, если строка сбалансирована, иначе 0                               |


### Код программы:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define N 1000 // максимальная длина входной строки

// Описываем структуру стэка:
typedef struct {
    int top; // индекс последнего добавленного символа
    char *data; // массив со скобками
    int size; // максимальная длина массива (защита от перезаписи)
} Stack;

// Инициализация стека
int init(Stack *s, int n) {
    s->top = -1; // индекс последнего добавленного символа приравниваем к -1 чтобы при добавлении первого элемента его индекс в массиве стал 0.
    s->size = n; 
    s->data = malloc(n * sizeof(char)); // выделяем память под массив скобок
    if (NULL == s->data) { // Проверка выделения памяти
        fprintf(stderr, "Ошибка выделения памяти.\n");
        return 0;
    }
    return 1;
}

// Добавление элемента в стек
void push(Stack *s, char c) {
    if (s->top < s->size - 1) {
        s->data[++s->top] =  c;
    } else {
        fprintf(stderr, "ошибка: переполнение стека\n");
        exit(1);
    }
}

// Получение элемента из стека
char pop(Stack *s) {
    if (s->top >= 0) // проверка пуст ли стек.
    {
        return s->data[s->top--]; // возращаем последний элемент массива, после чего уменьшаем последний индекс на 1.
    }
    return 0; // Пусто, ничего нет
}

// Проверка на совпадение скобок. Просто выносим чтобы не загромождат.
int isMatch(char open, char close) {
    return (open == '(' && close == ')') ||
           (open == '[' && close == ']') ||
           (open == '{' && close == '}');
}

// Проверка, пуст ли стек
int isEmpty(Stack *s) {
    return s->top == -1;
}

// Основная функция проверки сбалансированности
int isBalanced(char *str) {
    // Инициализация стэка
    Stack s;
    if (!init(&s, strlen(str))) {
        return 0; // Ошибка инициализации
    }
    // Пробегаемся по входной строке.
    for (int i = 0; str[i]; i++) {
        char c = str[i]; // Для удобства вынесем в отдельную переменную символ
        if (c == '(' || c == '[' ||  c == '{') // проверка на открывающуюся скобочку -> кладем в стек
        {
            push(&s, c);
        } else if (c == ')' ||  c == ']' || c == '}') // если скобка закрывающаяся, стек пуст или нету подходящей открывающийся из стека == несбалансированность
        {
            if (isEmpty(&s) || !isMatch(pop(&s), c)) {
                free(s.data);
                return 0;
            }
        }
    }
    int ok = isEmpty(&s); // проверка остались ли непарные открывающиеся скобки
    free(s.data); // Очистка памяти
    return ok;
}

int main() {
    char s[N];
    if (!fgets(s, N, stdin)) { // Проверка на успешный ввод
        fprintf(stderr, "Ошибка ввода.\n");
        return 1;
    }

    // Убираем символ новой строки, если он есть
    size_t len = strlen(s);
    if (len > 0 && s[len - 1] == '\n') {
        s[len - 1] = '\0';
    }
    // проверка на пустую строку
    if (s[0] == '\0') {
        puts("NO");
        return 0;
    }

    // проверка на сбалансированность
    puts(isBalanced(s) ? "YES" : "NO");
    return 0;
} 
```

## ЗАДАЧА №2: Вычисление выражения в постфиксной нотации.

### Цель: Написать программу, вычисляющую значение арифметического выражения, заданного в обратной польской (постфиксной) записи.

Список идентификаторов

| Название       | Тип               | Смысл переменной/функции                                             |
|----------------|------------------|-----------------------------------------------------------------------|
| `MAX`          | `#define`        | Максимальная длина входной строки                                     |
| `Stack`        | `struct`         | Структура для представления стека чисел                               |
| `data`         | `int *`          | Массив для хранения элементов стека                                   |
| `top`          | `int`            | Индекс вершины стека (последнего добавленного элемента)               |
| `size`         | `int`            | Максимальный размер стека                                             |
| `init`         | `function`       | Инициализация стека                                                   |
| `freeStack`    | `function`       | Освобождение памяти, занятой стеком                                   |
| `isFull`       | `function`       | Проверка на переполнение стека                                        |
| `isEmpty`      | `function`       | Проверка, пуст ли стек                                                |
| `push`         | `function`       | Добавление значения в стек                                            |
| `pop`          | `function`       | Извлечение значения из стека                                          |
| `apply`        | `function`       | Выполнение арифметической операции                                    |
| `evaluate`     | `function`       | Основная логика обработки выражения в постфиксной форме               |
| `input`        | `char[]`         | Строка, содержащая введённое пользователем выражение                  |
| `len`          | `size_t`         | Длина введённой строки                                                |
| `i`            | `int`            | Индекс для итерации по строке                                         |
| `num`          | `int`            | Промежуточное значение для сборки числа из цифр                       |
| `sign`         | `int`            | Знак числа: `+1` или `-1`                                             |
| `a`, `b`       | `int`            | Операнды для арифметической операции                                  |
| `res`          | `int`            | Результат выполнения операции                                         |
| `err`, `err1`, `err2`, `op_err` | `int` | Флаги ошибок (например, ошибка при извлечении, деление на ноль) |
| `result`       | `int`            | Конечный результат вычисления выражения                               |

### Код программы:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX 1000 // максимальная длина входной строки

// описываем структуру стека для хранения чисел
typedef struct {
    int *data; // массив для хранения чисел
    int top;   // индекс последнего добавленного элемента
    int size;  // максимальный размер стека
} Stack;

// инициализация стека
int init(Stack *s, int n) {
    s->top = -1;
    s->size = n;
    s->data = malloc(sizeof(int) * n); // выделяем память под массив чисел
    if (NULL == s->data) {
        fprintf(stderr, "ошибка выделения памяти.\n");
        return 0;
    }
    return 1; //  возвращаем 1 при успешной инициализации
}

// добавление элемента в стек
void push(Stack *s, int c) {
    if (s->top < s->size - 1) {
        s->data[++s->top] =  c;
    } else {
        fprintf(stderr, "ошибка: переполнение стека\n");
        exit(1);
    }
}

// извлечение элемента из стека
int pop(Stack *s, int *err) {
    if (s->top >= 0) {
        *err = 0; //  ошибка не возникла
        return s->data[s->top--]; // возвращаем значение и уменьшаем индекс
    }
    *err = 1; // устанавливаем флаг ошибки (пустой стек)
    return 0;
}

// функция, выполняющая операцию
int apply(int a, int b, char op, int *err) {
    if (op == '/' && b == 0) {
        *err = 1; // ошибка деления на ноль
        return 0;
    }
    *err = 0;
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        default: *err = 1; return 0; // неизвестный оператор
    }
}

int main() {
    char input[MAX];
    if (!fgets(input, MAX, stdin)) {
    fprintf(stderr, "ошибка ввода.\n");
    return 1;
    }

    // удаляем символ новой строки
    char *newline = strchr(input, '\n');
    if (newline) *newline = '\0';

    // проверка на пустую строку после удаления \n
    if (input[0] == '\0') {
        puts("Не хватает входных данных");
        return 1;
    }

    // инициализируем стек
    Stack s;
    if (!init(&s, MAX)) return 1;

    for (int i = 0; input[i];) {
        // пропускаем пробелы и продолжаем дальше итерироваться
        if (input[i] == ' ') {
            i++;
            continue;
        }

        // обработка чисел (в том числе отрицательных)
        if (isdigit(input[i]) || (input[i] == '-' && isdigit(input[i + 1]))) {
            int num = 0;
            int sign = 1; // по умолчанию положительное
            if (input[i] == '-') {
                sign = -1;
                i++;
            }
            // проверка на многозначное число и преобразование
            while (isdigit(input[i])) {
                num = num * 10 + (input[i] - '0'); //  собираем число по цифрам
                i++;
            }
            push(&s, sign * num); //  кладём число в стек
            continue;
        }

        // обработка операторов
        if (strchr("+-*/", input[i])) {
            int err1 = 0, err2 = 0;
            int b = pop(&s, &err1); // второй операнд
            int a = pop(&s, &err2); // первый операнд

            // если произошла ошибка извлечения операндов
            if (err1 || err2) {
                fprintf(stderr, "ошибка: недостаточно операндов для операции '%c'\n", input[i]);
                free(s.data);
                return 1;
            }

            // выполняем операцию
            int op_err = 0;
            int res = apply(a, b, input[i], &op_err);
            if (op_err) {
                fprintf(stderr, "ошибка: деление на ноль или недопустимая операция '%c'\n", input[i]);
                free(s.data);
                return 1;
            }

            push(&s, res); // кладём результат обратно
            i++;
            continue;
        }

        // если встретили недопустимый символ
        fprintf(stderr, "ошибка: недопустимый символ '%c'\n", input[i]);
        free(s.data);
        return 1;
    }

    // после завершения должна остаться ровно одна переменная в стеке
    if (s.top == 0) {
        printf("результат: %d\n", s.data[s.top]);
    } else {
        fprintf(stderr, "ошибка: в стеке осталось %d элементов\n", s.top + 1);
        free(s.data);
        return 1;
    }

    free(s.data); // освобождаем память
    return 0;
}


```

## ЗАДАЧА №3: Генерация треугольника Паскаля.
### Цель: Написать программу, которая выводит первые N строк треугольника Паскаля.

### Математическая модель треугольника Паскаля 

1. Первый элемент в каждой строке — **1**  
2. Последний элемент в каждой строке — **1**  
3. Внутренние элементы вычисляются по формуле:

\[
P(i, j) = P(i - 1, j - 1) + P(i - 1, j)
\]

где:
- \( i \) — номер строки (начиная с 0)
- \( j \) — номер элемента в строке (от 0 до i)

## Начальные условия:
- \( P(0, 0) = 1 \)
- \( P(i, 0) = P(i, i) = 1 \)


### Cписок идентификаторов

| Название       | Тип               | Смысл переменной                                                               |
|----------------|------------------|---------------------------------------------------------------------------------|
| `N`            | `int`            | Количество рядов в треугольнике Паскаля                                         |
| `arr`          | `int**`          | Динамический двумерный массив для хранения значений треугольника                |
| `i`            | `int`            | Счётчик внешнего цикла (номер строки)                                           |
| `j`            | `int`            | Счётчик внутреннего цикла (номер элемента в строке)                             |

### Код программы:

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    int N;

    // ввод количество рядов в треугольнике Паскаля
    printf("Введите количество рядов: ");
    // проверка что число одно и оно больше нуля
    if (scanf("%d", &N) != 1 || N <= 0) {
        fprintf(stderr, "Ошибка: введите положительное целое число.\n");
        return 1;
    }

    // выделяем память под массив указателей (строк)
    int **arr = malloc(N * sizeof(int *));
    if (arr == NULL) {
        fprintf(stderr, "Ошибка выделения памяти.\n");
        return 1;
    }

    // для каждой строки выделяем память под (i + 1) элементов
    for (int i = 0; i < N; i++) {
        arr[i] = malloc((i + 1) * sizeof(int));
        if (arr[i] == NULL) {
            fprintf(stderr, "Ошибка выделения памяти на строку %d.\n", i);
            // освобождаем уже выделенную память перед выходом
            for (int j = 0; j < i; j++) {
                free(arr[j]);
            }
            free(arr);
            return 1;
        }
    }

    // строим треугольник Паскаля
    for (int i = 0; i < N; i++) {
        arr[i][0] = 1;
        arr[i][i] = 1;
        for (int j = 1; j < i; j++) {
            arr[i][j] = arr[i-1][j-1] + arr[i-1][j];
        }
    }

    // выводим треугольник
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= i; j++) {
            printf("%4d", arr[i][j]); // форматированный вывод для красоты
        }
        printf("\n");
    }

    // освобождаем память
    for (int i = 0; i < N; i++) {
        free(arr[i]);
    }
    free(arr);

    return 0;
}
```

## ЗАДАЧА №4 Арифметические операции с дробями.

###  Цель: Разработайте программу для выполнения основных операций с обыкновенными дробями.

### Список идентификаторов

| Название         | Тип        | Назначение                                                                 |
|------------------|------------|----------------------------------------------------------------------------|
| `Fraction`       | `struct`   | Структура для представления дроби (числитель и знаменатель)                |
| `num`            | `int`      | Числитель дроби                                                            |
| `den`            | `int`      | Знаменатель дроби                                                          |
| `gcd`            | `function` | Функция для нахождения наибольшего общего делителя (НОД)                   |
| `reduce`         | `function` | Функция сокращения дроби                                                   |
| `add`            | `function` | Функция сложения двух дробей                                               |
| `subtract`       | `function` | Функция вычитания одной дроби из другой                                    |
| `multiply`       | `function` | Функция умножения двух дробей                                              |
| `divide`         | `function` | Функция деления одной дроби на другую, с проверкой деления на ноль         |
| `printFraction`  | `function` | Функция вывода дроби в формате `a/b` или `a`, если знаменатель равен 1     |
| `a`, `b`         | `Fraction` | Входные дроби, вводимые пользователем                                      |
| `result`         | `Fraction` | Результат вычисления                                                       |
| `op`             | `char`     | Символ операции: `+`, `-`, `*`, `/`                                        |
| `error`          | `int`      | Флаг ошибки (1 — деление на ноль, 0 — всё нормально) 

### Код программы:

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int num; // числитель
    int den; // знаменатель
} Fraction;

// Вычисление наибольшего общего делителя (алгоритм Евклида)
int gcd(int a, int b) {
    return b == 0 ? abs(a) : gcd(b, a % b);
}

// Функция окращение дроби которая будет использоваться в последующем для всех операций
Fraction reduce(Fraction f) {
    int g = gcd(f.num, f.den);
    f.num /= g;
    f.den /= g;
    if (f.den < 0) { // знак всегда у числителя
        f.num = -f.num;
        f.den = -f.den;
    }
    return f;
}

// Операции с дробями
// сложение
Fraction add(Fraction a, Fraction b) {
    Fraction res = {a.num * b.den + b.num * a.den, a.den * b.den};
    return reduce(res);
}
// вычитание
Fraction subtract(Fraction a, Fraction b) {
    Fraction res = {a.num * b.den - b.num * a.den, a.den * b.den};
    return reduce(res);
}

// умножение
Fraction multiply(Fraction a, Fraction b) {
    Fraction res = {a.num * b.num, a.den * b.den};
    return reduce(res);
}

// деление
Fraction divide(Fraction a, Fraction b, int *error) {
    if (b.num == 0) {
        *error = 1;
        return (Fraction){0, 1};
    }
    Fraction res = {a.num * b.den, a.den * b.num};
    return reduce(res);
}

// Печать дроби
void printFraction(Fraction f) {
        printf("Результат: %d/%d\n", f.num, f.den);
}

int main() {
    Fraction a, b, result;
    char op;
    int error = 0;

    printf("Введите выражение (например, 1/2 + 3/4 (минусы ставьте сразу перед цифрой)): ");

    if (scanf("%d/%d %c %d/%d", &a.num, &a.den, &op, &b.num, &b.den) != 5) {
        printf("Ошибка: неверный формат. Используйте a/b <операция> c/d.\n");
        return 1;
    }

    if (a.den == 0 || b.den == 0) {
        printf("Ошибка: знаменатель не должен быть равен нулю.\n");
        return 1;
    }

    switch (op) {
        case '+': result = add(a, b); break;
        case '-': result = subtract(a, b); break;
        case '*': result = multiply(a, b); break;
        case '/':
            result = divide(a, b, &error);
            if (error) {
                printf("Ошибка: деление на ноль.\n");
                return 1;
            }
            break;
        default:
            printf("Ошибка: недопустимая операция '%c'.\n", op);
            return 1;
    }

    printFraction(result);
    return 0;
}
```